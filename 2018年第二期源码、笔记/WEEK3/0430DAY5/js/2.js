// let str = 'zhufeng{2018}peixun{2019}yangfan{2020}qihang{2021}';
// let reg = /\{(\d+)\}/g;//=>大括号有特殊含义：{N}出现的次数

// console.log(reg.exec(str));//=>['{2018}','2018'] 在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到（数组第一项），而且把小分组匹配的内容也单独抽取出来（数组中的第二项开始就是小分组捕获的内容） =>“分组捕获” ，而/\{(?:\d+)\}/g  ?:是用来阻止分组捕获内容的“只匹配不捕获”

// console.log(str.match(reg));//=>["{2018}", "{2019}", "{2020}", "{2021}"]  MATCH方法也有自己的局限性，在正则设置了G的情况下，基于MATCH捕获的内容只有大正则匹配的，小分组的内容没有单独抽取出来（不设置G的情况下和执行EXEC一样）

//===========================
//=>正则捕获还具备贪婪性：每一次匹配捕获的时候，总是捕获到和正则匹配中最长的内容，例如: '2' 符合 \d+  '2018' 也符合 \d+，但是捕获的是最长的内容 '2018'...
let str = 'zhufeng2018peixun2019';
let reg = /\d+?/g;//=>把问号放到量词元字符后面，代表的就不是出现零次或者一次了，而且取消捕获的贪婪性
console.log(reg.exec(str));//=>['2']

/*
 * ?在正则中的作用
 *   1.量词元字符：出现零次或者一次
 *     /-?/ 让减号出现一次或者不出现
 *
 *   2.取消贪婪性
 *     /\d+?/ 捕获的时候只捕获最短匹配的内容
 *
 *   3.?: 只匹配不捕获
 *
 *   4.?= 正向预查
 *
 *   5.?! 负向预查
 */






